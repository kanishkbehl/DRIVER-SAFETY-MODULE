# Detects:
# - Helmet usage and phone usage using YOLOv8 custom model
# - Eye closure and yawning using second YOLOv8 model trained for facial states
# - Displays bounding boxes and labels with color-coded annotations
# - Controls GPIO outputs for real-time alerts:
#     • Green LED: Helmet detected
#     • Red LED: No helmet detected
#     • Blue LED: Phone detected
#     • Yellow LED: Yawning detected
#     • White LED: Eyes closed detected
#     • Buzzer: Activated for any safety violation (phone, eyes closed, yawning, or no helmet)
# - Uses PiCamera2 with 1280x720 resolution for high-quality detection
# - Resizable OpenCV window for live video feed visualization
# - Modular detection logic using `process_eye_detections()` for cleaner handling of face-related alerts
# Designed to run on Raspberry Pi with connected GPIO peripherals and dual YOLO models

# -*- coding: utf-8 -*-
"""driver_safety_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ODO7kgqQ6HzmVchjp7p-cmOdMWF5VMs2
"""

import cv2
import time
from gpiozero import LED, Buzzer
from ultralytics import YOLO
from picamera2 import Picamera2

# Initialize GPIO
buzzer = Buzzer(18)
led_helmet = LED(23)       # Green: Helmet detected
led_no_helmet = LED(25)    # Red: No helmet
led_phone = LED(24)        # Blue: Phone detected
led_yawn = LED(26)         # Yellow: Yawning detected
led_eyes_closed = LED(27)  # White: Eyes closed detected

# Load models
helmet_phone_model = YOLO("/home/pi/Desktop/Models and codes/newhelemt_phone.pt")
eye_yawn_model = YOLO("/home/pi/Desktop/Models and codes/eyes_yarn.pt")

# Print class names for debugging
print("Eye/Yawn Model Classes:", eye_yawn_model.names)

# Camera setup with higher resolution
picam2 = Picamera2()
config = picam2.create_preview_configuration(main={"size": (1280, 720)})  # Higher resolution
picam2.configure(config)
picam2.start()
time.sleep(2)

# Set display window size
display_width = 1280
display_height = 720

# Color definitions
COLORS = {
    'helmet': (0, 255, 0),      # Green
    'no_helmet': (0, 0, 255),   # Red
    'phone': (255, 0, 0),       # Blue
    'yawn': (0, 255, 255),      # Yellow
    'eyes_open': (0, 255, 0),   # Green
    'eyes_closed': (255, 255, 255),  # White
    'default': (255, 255, 255)  # White
}

def process_eye_detections(frame, model):
    """Process eye/yawn detections with improved class handling"""
    results = model(frame, verbose=False)
    detections = []

    for result in results:
        for box in result.boxes:
            x1, y1, x2, y2 = map(int, box.xyxy[0])
            conf = box.conf[0].item()
            class_id = int(box.cls[0])
            class_name = model.names[class_id].lower()

            if conf > 0.5:  # Only confident detections
                # Determine detection type
                if 'yawn' in class_name:
                    label = "Yawn"
                    color = COLORS['yawn']
                    detection_type = 'yawn'
                elif any(word in class_name for word in ['closed', 'close', 'drowsy']):
                    label = "Eyes Closed"
                    color = COLORS['eyes_closed']
                    detection_type = 'eyes_closed'
                elif 'open' in class_name:
                    label = "Eyes Open"
                    color = COLORS['eyes_open']
                    detection_type = 'eyes_open'
                else:
                    label = class_name
                    color = COLORS['default']
                    detection_type = class_name

                detections.append({
                    'box': (x1, y1, x2, y2),
                    'conf': conf,
                    'label': label,
                    'color': color,
                    'type': detection_type
                })

                # Draw bounding box and label with larger text
                cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                cv2.putText(frame, f"{label} {conf:.2f}", (x1, y1-5),
                          cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

    return detections

# Create a resizable window
cv2.namedWindow("Safety Monitoring System", cv2.WINDOW_NORMAL)
cv2.resizeWindow("Safety Monitoring System", display_width, display_height)

while True:
    # Capture frame
    frame = picam2.capture_array()
    frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)

    # Resize to fit the display window
    frame = cv2.resize(frame, (display_width, display_height), interpolation=cv2.INTER_LINEAR)

    # Reset detection flags
    detections = {
        'helmet': False,
        'phone': False,
        'yawn': False,
        'eyes_closed': False,
        'eyes_open': False
    }

    # Helmet and phone detection
    hp_results = helmet_phone_model(frame, verbose=False)
    for result in hp_results:
        for box in result.boxes:
            x1, y1, x2, y2 = map(int, box.xyxy[0])
            conf = box.conf[0].item()
            class_id = int(box.cls[0])
            class_name = helmet_phone_model.names[class_id].lower()

            if conf > 0.5:
                if 'helmet' in class_name:
                    detections['helmet'] = True
                    color = COLORS['helmet']
                    label = "Helmet"
                elif 'phone' in class_name:
                    detections['phone'] = True
                    color = COLORS['phone']
                    label = "Phone"

                cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                cv2.putText(frame, f"{label} {conf:.2f}", (x1, y1-5),
                          cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

    # Eye and yawn detection - using the improved function
    eye_detections = process_eye_detections(frame, eye_yawn_model)
    for det in eye_detections:
        detections[det['type']] = True

    # Display status with larger text
    y_offset = 30
    status_lines = [
        f"Helmet: {'DETECTED' if detections['helmet'] else 'MISSING'}",
        f"Phone: {'DETECTED' if detections['phone'] else 'Not detected'}",
        f"Eyes: {'CLOSED' if detections['eyes_closed'] else 'Open'}",
        f"Yawn: {'DETECTED' if detections['yawn'] else 'Not detected'}"
    ]

    for line in status_lines:
        color = COLORS['default']
        if "Helmet" in line:
            color = COLORS['helmet'] if "DETECTED" in line else COLORS['no_helmet']
        elif "Phone" in line and "DETECTED" in line:
            color = COLORS['phone']
        elif "CLOSED" in line:
            color = COLORS['eyes_closed']
        elif "Yawn" in line and "DETECTED" in line:
            color = COLORS['yawn']

        cv2.putText(frame, line, (10, y_offset),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)
        y_offset += 30

    # Control LEDs and buzzer
    led_helmet.on() if detections['helmet'] else led_helmet.off()
    led_no_helmet.on() if not detections['helmet'] else led_no_helmet.off()
    led_phone.on() if detections['phone'] else led_phone.off()
    led_yawn.on() if detections['yawn'] else led_yawn.off()
    led_eyes_closed.on() if detections['eyes_closed'] else led_eyes_closed.off()

    # Activate buzzer for any violation
    buzzer.on() if (detections['phone'] or detections['eyes_closed'] or
                   detections['yawn'] or not detections['helmet']) else buzzer.off()

    # Show frame in the resizable window
    cv2.imshow("Safety Monitoring System", frame)

    # Exit on 'q'
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Cleanup
buzzer.off()
for led in [led_helmet, led_no_helmet, led_phone, led_yawn, led_eyes_closed]:
    led.off()
cv2.destroyAllWindows()
picam2.stop()